{"mappings":"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","sources":["node_modules/hyplate/src/util.ts","node_modules/hyplate/src/internal.ts","node_modules/hyplate/src/core.ts","node_modules/hyplate/src/binding.ts","node_modules/hyplate/src/jsx-runtime.ts","node_modules/hyplate/src/custom-elements.ts","node_modules/hyplate/src/slot.ts","node_modules/hyplate/src/directive.ts","node_modules/hyplate/src/store.ts","src/calculate.ts","src/main.tsx"],"sourcesContent":["/**\n * @license MIT\n * Copyright (C) 2022  DarrenDanielDay <Darren_Daniel_Day@hotmail.com>\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { AnyFunc } from \"./types.js\";\n\nexport let __DEV__ = process.env.NODE_ENV !== \"production\";\n\nexport const setMode = (isDev: boolean) => (__DEV__ = isDev);\n\nexport const patch: <T extends unknown>(a: T, b: Partial<T>) => T = Object.assign;\n\nexport const once = <T extends unknown>(evaluate: () => T) => {\n  let evaluated = false;\n  let value: T;\n  return (): T => {\n    if (evaluated) {\n      return value;\n    }\n    evaluated = true;\n    return (value = evaluate());\n  };\n};\n\nexport const scopes = <T extends {}>() => {\n  const stack: T[] = [];\n  const resolve = () => stack.at(-1);\n  const enter = (val: T) => push(stack, val);\n  const quit = () => {\n    pop(stack);\n  };\n  return [enter, quit, resolve] as const;\n};\n\nexport const arrayFrom = Array.from;\n\nexport const push = <T extends unknown>(arr: T[], val: T) => arr.push(val);\n\nexport const pop = <T extends unknown>(arr: T[]) => arr.pop();\n\nexport const noop = () => {};\n\nexport const applyAll = (cleanups: (() => void)[]) => {\n  // The side effects are revoked in the reversed order.\n  for (let i = cleanups.length - 1; i >= 0; i--) {\n    cleanups[i]!();\n  }\n};\n\n/**\n * In many cases the `cleanups` array never grow. In that case we can use `noop` for fewer memory usage.\n */\nexport const applyAllStatic = (cleanups: (() => void)[]): (() => void) =>\n  cleanups.length ? () => applyAll(cleanups) : noop;\n\nexport const isString = (v: unknown): v is string => typeof v === \"string\";\n\nexport const isFunction = (v: unknown): v is AnyFunc => typeof v === \"function\";\n\nexport const isObject = (v: unknown): v is object => v != null && typeof v === \"object\";\n\nexport const isArray = Array.isArray;\n\nexport const isInstance =\n  <T>(ctor: new (...args: any[]) => T) =>\n  (value: unknown): value is T =>\n    value instanceof ctor;\n\nexport const strictEqual = Object.is;\n\nexport const defineProp = Object.defineProperty;\n\nexport const compare = Object.is;\n\nexport const err = (error: unknown) => {\n  const msg =\n    error instanceof Error\n      ? `stack trace: \n${error.stack}`\n      : JSON.stringify(error);\n  console.error(`[ERROR]: ${msg}`);\n};\n\nexport const warn = (msg: unknown) => {\n  if (__DEV__) {\n    console.warn(msg);\n  }\n};\n\nexport const warned = <T extends unknown>(msg: string, value: T) => {\n  warn(msg);\n  return value;\n};\n\nexport const objectEntriesMap = <T, R>(obj: Record<string, T>, mapper: ([k, v]: [string, T]) => R) =>\n  Object.fromEntries(Object.entries(obj).map(([key, value]) => [key, mapper([key, value])]));\n\nexport const fori = <T extends unknown>(arrayLike: ArrayLike<T>, callback: (element: T) => void) => {\n  for (let i = 0, l = arrayLike.length; i < l; i++) callback(arrayLike[i]);\n};\n","/**\n * @license MIT\n * Copyright (C) 2022  DarrenDanielDay <Darren_Daniel_Day@hotmail.com>\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type {\n  CleanUpFunc,\n  EventHandlerOptions,\n  FunctionalEventHanlder,\n  Handler,\n  NativeSlotContent,\n  Reflection,\n} from \"./types.js\";\nimport { err, fori, isInstance, noop, push, __DEV__ } from \"./util.js\";\n\nexport const doc = document;\n\nexport const comment = (message: string) => doc.createComment(__DEV__ ? message : \"\");\n\nexport const withCommentRange = (message: string): [begin: Comment, end: Comment, clearRange: CleanUpFunc] => {\n  const begin = comment(` ${message} begin `);\n  const end = comment(` ${message} end `);\n  return [\n    begin,\n    end,\n    () => {\n      const range = new Range();\n      range.setStart(begin, begin.length);\n      range.setEnd(end, 0);\n      range.deleteContents();\n      range.detach();\n    },\n  ];\n};\n\nexport const addCleanUp = (cleanups: CleanUpFunc[], cleanup: CleanUpFunc) => {\n  if (cleanup !== noop) {\n    push(cleanups, cleanup);\n  }\n};\n\nexport const _listen = (\n  target: EventTarget,\n  name: string,\n  hander: Handler<any, any>,\n  options?: EventHandlerOptions\n): CleanUpFunc => {\n  target.addEventListener(name, hander, options);\n  return () => {\n    target.removeEventListener(name, hander, options);\n  };\n};\n\nexport const _delegate = (el: Element, event: string, handler: FunctionalEventHanlder<any, any>) => {\n  const root = el.ownerDocument;\n  const delegatedEvents = (root.$$delegates ??= new Set<string>());\n  if (!delegatedEvents.has(event)) {\n    delegatedEvents.add(event);\n    root.addEventListener(event, globalDelegateEventHandler);\n  }\n  const handlerProperty = `_$${event}` as const;\n  el[handlerProperty] = handler;\n  return () => {\n    delete el[handlerProperty];\n  };\n};\n\nconst globalDelegateEventHandler = (e: Event) => {\n  const eventHandlerProperty = `_$${e.type}` as const;\n  const targets = e.composedPath();\n  fori(targets, (target) => {\n    const handler = target[eventHandlerProperty];\n    if (handler != null) {\n      try {\n        handler.call(target, e);\n      } catch (error) {\n        err(error);\n      }\n    }\n  });\n};\n\nexport const isNode = /* #__PURE__ */ isInstance(Node);\n\nexport const isFragment = /* #__PURE__ */ isInstance(DocumentFragment);\n\nexport const isTemplate = /* #__PURE__ */ isInstance(HTMLTemplateElement);\n\nconst isText = /* #__PURE__ */ isInstance(Text);\n\nconst isElement = /* #__PURE__ */ isInstance(Element);\n\nexport const isValidSlotContent = (node: unknown): node is NativeSlotContent => isText(node) || isElement(node);\n\nexport const reflection: Reflection<string> = /* #__PURE__ */ new Proxy({}, { get: (_, k) => k });\n\nexport const $$HyplateSubscribers: unique symbol = \"_$subs\" as never;\n","/**\n * @license MIT\n * Copyright (C) 2022  DarrenDanielDay <Darren_Daniel_Day@hotmail.com>\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type { ParseSelector } from \"typed-query-selector/parser.js\";\nimport type {\n  AttachFunc,\n  AttributeInterpolation,\n  DelegateHost,\n  EventHost,\n  GetRange,\n  TextInterpolation,\n} from \"./types.js\";\nimport { arrayFrom, fori, isString, push } from \"./util.js\";\nimport { comment, doc, _delegate, _listen } from \"./internal.js\";\nexport { comment } from \"./internal.js\";\n\nexport const element = /* #__PURE__ */ doc.createElement.bind(doc);\n\nexport const text = /* #__PURE__ */ doc.createTextNode.bind(doc);\n\nexport const svg: <K extends keyof SVGElementTagNameMap>(name: K) => SVGElementTagNameMap[K] = (name) =>\n  doc.createElementNS(\"http://www.w3.org/2000/svg\", name);\n\nexport const mathml: (name: string) => MathMLElement = (name) =>\n  doc.createElementNS(\"http://www.w3.org/1998/Math/MathML\", name) as MathMLElement;\n\nexport const fragment = /* #__PURE__ */ doc.createDocumentFragment.bind(doc);\n\nexport const clone = <N extends Node>(node: N): N => node.cloneNode(true) as N;\n\nexport const attr = (element: Element, name: string, value: AttributeInterpolation) =>\n  value == null || value === false ? element.removeAttribute(name) : element.setAttribute(name, `${value}`);\n\nexport const content = (node: Node, content: TextInterpolation) => (node.textContent = `${content}`);\n\nexport const select: {\n  <S extends string>(host: ParentNode, selecor: S): ParseSelector<S> | null;\n  <S extends string>(selecor: S): ParseSelector<S> | null;\n} = <S extends string>(host: ParentNode | S, selecor?: S): ParseSelector<S> | null =>\n  isString(host) ? doc.querySelector(host) : host.querySelector(selecor!);\n\nexport const anchor: {\n  (hid: string): HTMLTemplateElement | null;\n  (owner: ParentNode, hid: string): Element | null;\n} = (p1, p2?) => {\n  if (isString(p1)) {\n    return doc.querySelector(`template[\\\\#${p1}]`);\n  }\n  return p1.querySelector(`[\\\\#${p2}]`);\n};\n\nexport const $: <S extends string>(selector: S) => ParseSelector<S> = /* #__PURE__ */ doc.querySelector.bind(doc);\n\nexport const $$ = <S extends string>(selector: S): ParseSelector<S>[] => arrayFrom(doc.querySelectorAll(selector));\n\nexport const listen =\n  <T extends EventTarget>(target: T): EventHost<T> =>\n  (name, handler, options) =>\n    _listen(target, name, handler, options);\n\nexport const delegate =\n  <T extends Element>(el: T): DelegateHost<T> =>\n  (event, handler) =>\n    _delegate(el, event, handler);\n\nexport const appendChild =\n  (host: Node): AttachFunc =>\n  (node) =>\n    host.appendChild(node);\n\nexport const before =\n  (anchorNode: Node): AttachFunc =>\n  (node) =>\n    anchorNode.parentNode!.insertBefore(node, anchorNode);\n\nexport const after =\n  (element: ChildNode): AttachFunc =>\n  (node) =>\n    element.after(node);\n\nexport const seqAfter = (element: ChildNode): AttachFunc => {\n  const begin = comment(\" sequence after begin \");\n  const end = comment(\" sequence after end \");\n  const append = after(element);\n  append(begin);\n  append(end);\n  return before(end);\n};\n\nexport const remove: AttachFunc = (node: Node) => node.parentNode?.removeChild(node);\n\nexport const moveRange = (begin: Node | null, end: Node | null, attach: AttachFunc) => {\n  const targets: Node[] = [];\n  for (let node = begin; node && node !== end; node = node.nextSibling) {\n    push(targets, node);\n  }\n  if (end) {\n    push(targets, end);\n  }\n  fori(targets, attach);\n};\n\nexport const removeRange = (getRange: GetRange) => {\n  const range = getRange();\n  if (range) {\n    moveRange(range[0], range[1], remove);\n  }\n};\n\nexport const access = (node: ParentNode, path: number[]): ParentNode | undefined => {\n  for (let i = 0, l = path.length; i < l; i++) {\n    node = node.children[path[i]];\n    if (!node) {\n      break;\n    }\n  }\n  return node;\n};\n","import { attr, content, text } from \"./core.js\";\nimport type {\n  AttachFunc,\n  AttributeInterpolation,\n  AttributesMap,\n  BindingPattern,\n  CleanUpFunc,\n  Subscribable,\n  SubscribableTester,\n  SubscribeFunc,\n  TextInterpolation,\n} from \"./types.js\";\nimport { applyAllStatic, err, isObject, noop, push, warn, __DEV__ } from \"./util.js\";\n\nconst defaultSubscribe: SubscribeFunc = (subscribable, subscriber) => {\n  if (__DEV__) {\n    warn(`No \"subscribe\" function configured. No subscription will be created, and any bindings won't work.`);\n    warn({ subscribable, subscriber });\n  }\n  return noop;\n};\n\nexport let subscribe: SubscribeFunc = defaultSubscribe;\n\nconst defaultIsSubscribable = (value: unknown): value is Subscribable<unknown> => {\n  if (__DEV__) {\n    warn(`No \"isSubscribable\" function configured.`);\n  }\n  return isObject(value);\n};\nexport let isSubscribable: SubscribableTester = defaultIsSubscribable;\n\nexport const configureBinding: (subscribe: SubscribeFunc, isSubscribable: SubscribableTester) => void = (\n  sub,\n  canSub\n) => {\n  subscribe = sub;\n  isSubscribable = canSub;\n};\n\nexport const resetBinding = () => {\n  subscribe = defaultSubscribe;\n  isSubscribable = defaultIsSubscribable;\n};\n\nexport const $content = (node: Node, subscribable: Subscribable<TextInterpolation>) =>\n  subscribe(subscribable, (text) => content(node, text));\n\nexport const $text = (fragments: TemplateStringsArray, ...bindings: BindingPattern<TextInterpolation>[]) => {\n  const bindingsLength = bindings.length;\n  if (__DEV__) {\n    const fragmentsLength = fragments.length;\n    if (fragmentsLength !== bindingsLength + 1) {\n      err(\n        `Invalid usage of \"text\". Fragments length(${fragments.length}) and bindings length(${bindings.length}) do not match.`\n      );\n    }\n    if (bindings.some((binding) => isObject(binding) && !isSubscribable(binding))) {\n      err(`Invalid usage of \"text\". Object text child must be a subscribable.`);\n    }\n  }\n  return (attach: AttachFunc): CleanUpFunc => {\n    const effects: CleanUpFunc[] = [];\n    const buf: string[] = [];\n    const flushBuf = () => {\n      const textContent = buf.join(\"\");\n      if (textContent) {\n        const textNode = text(textContent);\n        attach(textNode);\n      }\n      buf.length = 0;\n    };\n    for (let i = 0; i < bindingsLength; i++) {\n      push(buf, fragments[i]!);\n      const expression = bindings[i]!;\n      if (isSubscribable(expression)) {\n        flushBuf();\n        const dynamicText = text(\"\");\n        push(\n          effects,\n          subscribe(expression, (value) => (dynamicText.data = `${value}`))\n        );\n        attach(dynamicText);\n      } else {\n        push(buf, `${expression}`);\n      }\n    }\n    push(buf, fragments.at(-1)!);\n    flushBuf();\n    return applyAllStatic(effects);\n  };\n};\n\nexport const $attr: {\n  <E extends Element, P extends keyof AttributesMap<E>>(\n    el: E,\n    name: P,\n    subscribable: Subscribable<AttributesMap<E>[P]>\n  ): CleanUpFunc;\n  (el: Element, name: string, subscribable: Subscribable<AttributeInterpolation>): CleanUpFunc;\n} = (el: Element, name: string, subscribable: Subscribable<AttributeInterpolation>) =>\n  subscribe(subscribable, (attribute) => attr(el, name, attribute));\n","/**\n * @license MIT\n * Copyright (C) 2022  DarrenDanielDay <Darren_Daniel_Day@hotmail.com>\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { $attr, $text, isSubscribable } from \"./binding.js\";\nimport { appendChild, attr, fragment, element, svg, removeRange, mathml } from \"./core.js\";\nimport { anonymousElement, define } from \"./custom-elements.js\";\nimport { addCleanUp, isFragment, isNode, reflection, _delegate, _listen } from \"./internal.js\";\nimport { assignSlotMap, insertSlotMap, slotName } from \"./slot.js\";\nimport type {\n  JSXChildNode,\n  FunctionalComponent,\n  JSXChild,\n  AttachFunc,\n  CleanUpFunc,\n  AttributeInterpolation,\n  Rendered,\n  Props,\n  PropsBase,\n  Later,\n  ObjectEventHandler,\n  SlotMap,\n  Reflection,\n  Renderer,\n  JSXFactory,\n  ShadowRootConfig,\n  Mountable,\n} from \"./types.js\";\nimport {\n  applyAll,\n  applyAllStatic,\n  fori,\n  isArray,\n  isFunction,\n  isObject,\n  isString,\n  noop,\n  push,\n  __DEV__,\n} from \"./util.js\";\n\nexport const mount: Renderer = (element, onto): Rendered<any> => {\n  const attach = isNode(onto) ? appendChild(onto) : onto;\n  return element(attach);\n};\n\nexport const unmount = (rendered: Rendered<any>) => {\n  const [cleanup, , getRange] = rendered;\n  cleanup();\n  removeRange(getRange);\n};\n\nconst addChild = (child: JSXChild, attach: AttachFunc) => {\n  if (isNode(child)) {\n    attach(child);\n    return noop;\n  }\n  if (isFunction(child)) {\n    return mount(child, attach)[0];\n  }\n  return $text`${child}`(attach);\n};\n\nconst renderChild = (children: JSXChildNode, _attach: AttachFunc) => {\n  let begin: Node | null = null,\n    end: Node | null = null;\n  const attach: AttachFunc = (node) => {\n    const isFrag = isFragment(node);\n    if (!begin) {\n      if (isFrag) {\n        begin = node.firstChild;\n      } else {\n        begin = node;\n      }\n    }\n    if (isFrag) {\n      end = node.lastChild;\n    } else {\n      end = node;\n    }\n    return _attach(node);\n  };\n  const cleanups: CleanUpFunc[] = [];\n  if (isArray(children)) {\n    fori(children, (child) => {\n      addCleanUp(cleanups, addChild(child, attach));\n    });\n  } else {\n    addCleanUp(cleanups, addChild(children, attach));\n  }\n  return [cleanups, () => (begin && end ? ([begin, end] as const) : void 0)] as const;\n};\n\nconst isObjectEventHandler = (v: unknown): v is ObjectEventHandler<any> =>\n  isObject(v) && \"handleEvent\" in v && isFunction(v.handleEvent);\n\nlet currentElementFactory: (name: string, options: ElementCreationOptions | undefined) => Element = element;\n\n// @ts-expect-error unchecked overload\nexport const jsx: JSXFactory = (\n  type: FunctionalComponent | typeof Component | string,\n  props: Partial<Props<PropsBase, JSXChildNode, {}>>,\n  ...children: JSXChild[]\n): JSX.Element => {\n  props ??= {};\n  if (children.length) {\n    props.children = children.length === 1 ? children[0] : children;\n  }\n  if (typeof type === \"string\") {\n    return (attach): Rendered<object> => {\n      let lastElementFactory = currentElementFactory;\n      const isSvg = type === \"svg\";\n      const isForeignObject = type === \"foreignObject\";\n      const isMath = type === \"math\";\n      const changnigFactory = isSvg || isForeignObject || isMath;\n      //#region enter xml namespaced element creation scope\n      if (isSvg) {\n        // @ts-expect-error Skipped type check for svg children.\n        currentElementFactory = svg;\n      }\n      if (isMath) {\n        currentElementFactory = mathml;\n      }\n      //#endregion\n      const el = currentElementFactory(type, \"is\" in props && isString(props.is) ? { is: props.is } : void 0);\n      if (isForeignObject) {\n        currentElementFactory = element;\n      }\n      const { children, ref, ...attributes } = props;\n      if (ref) {\n        ref.current = el;\n      }\n      const [cleanups] = children != null ? renderChild(children, appendChild(el)) : [[]];\n      for (const key in attributes) {\n        // @ts-expect-error for-in key access\n        const value = attributes[key];\n        if (isSubscribable(value)) {\n          push(cleanups, $attr(el, key, value));\n        } else {\n          if (key.startsWith(\"on\")) {\n            const next = key[2];\n            if (\"A\" <= next && next <= \"Z\") {\n              const event = key.slice(2).toLowerCase();\n              if (isFunction(value)) {\n                push(cleanups, _listen(el, event, value));\n                continue;\n              } else if (isObjectEventHandler(value)) {\n                push(cleanups, _listen(el, event, value, value.options));\n                continue;\n              }\n            }\n            if (next === \":\") {\n              if (isFunction(value)) {\n                const event = key.slice(3).toLowerCase();\n                push(cleanups, _delegate(el, event, value));\n                continue;\n              }\n            }\n          }\n          attr(el, key, value as AttributeInterpolation);\n        }\n      }\n      attach(el);\n      if (changnigFactory) {\n        currentElementFactory = lastElementFactory;\n      }\n      return [applyAllStatic(cleanups), el, () => [el, el]];\n    };\n  }\n  if (isComponentClass(type)) {\n    return (attach) => {\n      // @ts-expect-error Dynamic Implementation\n      const instance: Component = new type(props);\n      return instance.mount(attach);\n    };\n  }\n  const { ref, ...otherProps } = props;\n  // @ts-expect-error Dynamic Implementation\n  const mountable = type(otherProps);\n  if (!ref) {\n    return mountable;\n  }\n  return (attach) => {\n    const rendered = mountable(attach);\n    // @ts-expect-error Dynamic Implementation\n    ref.current = rendered[1];\n    return rendered;\n  };\n};\nexport const jsxs = jsx;\nexport const h = jsx;\nexport const createElement = jsx;\n/**\n * Create a jsx ref object to fetch the DOM element when mounted.\n */\nexport const jsxRef = <E extends {}>(): Later<E> => ({\n  current: null,\n});\n\nexport const Fragment: FunctionalComponent<{}, JSXChildNode | undefined> = ({ children }) => {\n  return (attach) => {\n    const f = fragment();\n    const [cleanups, getRange] = children ? renderChild(children, appendChild(f)) : [[], noop];\n    attach(f);\n    return [applyAllStatic(cleanups), void 0, getRange];\n  };\n};\n\nexport const isComponentClass = (fn: Function): fn is typeof Component => !!(fn as typeof Component)?.__hyplate_comp;\n\nexport abstract class Component<P extends PropsBase = PropsBase, S extends string = string> extends HTMLElement {\n  /**\n   * @internal\n   */\n  static __hyplate_comp = true;\n  /**\n   * The shadow root init config except `mode`.\n   * In hyplate, we force the `mode` option to be `open`.\n   */\n  public static readonly shadowRootInit?: ShadowRootConfig;\n  /**\n   * The custom element name. Must be present, or it will explode.\n   */\n  public static readonly tag: string;\n  /**\n   * The slot element tag to be used when `shadowRootInit.slotAssignment` is `named`.\n   * You can configure it as `div`, `span` or other built-in tags.\n   * If not provided, hyplate will use a defined custom element with tag `${tag}-slot`.\n   */\n  public static readonly slotTag?: string;\n  /**\n   * Define this component as a custom element and the slot as a custom element, and then return it.\n   * @param tag the custom element tag name\n   */\n  public static defineAs(tag: string): string {\n    // @ts-expect-error abstract this\n    define(tag, this);\n    if (this.shadowRootInit?.slotAssignment === \"manual\" && !this.slotTag) {\n      define(slotName(tag), anonymousElement());\n    }\n    return tag;\n  }\n  /**\n   * If the component instance is created by HTML tag directly, the default props will be used.\n   * Only useful when you want to use the component directly by its tag name.\n   * Note that these default props will never be merged with given props in JSX.\n   * If you want to use a factory function, you can define a static `getter` like this:\n   * ```js\n   * class MyComponent extends Component {\n   *   static get defaultProps() {\n   *     return {\n   *       foo: \"bar\",\n   *     };\n   *   }\n   * }\n   * ```\n   */\n  public static defaultProps?: PropsBase;\n  /**\n   * By default, hyplate class component will not observe any attribute.\n   * Currently TypeScript cannot declare a static field/getter field.\n   * This getter is just for the type hint.\n   */\n  static get observedAttributes(): string[] {\n    return [];\n  }\n  /**\n   * In a hyplate class component, the `shadowRoot` property is ensured to be not null.\n   */\n  public declare shadowRoot: ShadowRoot;\n  /**\n   * Initialized in `setup`.\n   */\n  public props!: P;\n  public slots: Reflection<S> = reflection;\n  public cleanups: CleanUpFunc[] = [];\n  #children: SlotMap<S> | undefined;\n  #rendered: Rendered<this> | undefined;\n  #newTarget: typeof Component<any, any>;\n  public constructor(props?: Props<P, SlotMap<S> | undefined, {}>) {\n    super();\n    const newTarget = (this.#newTarget = new.target);\n    // @ts-expect-error cannot use `this` for Exposed\n    this.setup(props ?? newTarget.defaultProps);\n  }\n  /**\n   * The props setup step.\n   * You can override this to do the initialization stuff.\n   * Remember to call `super.setup(props)` first to ensure the default behavior.\n   */\n  public setup(props: Props<P, SlotMap<S> | undefined, this>): void {\n    let ref: Later<this> | undefined, children: SlotMap<S> | undefined;\n    // @ts-expect-error later updated type\n    const others: P = {};\n    const { cleanups } = this;\n    for (const key in props) {\n      // @ts-expect-error for in property access\n      const value = props[key];\n      if (key === \"ref\") {\n        ref = value;\n      } else if (key === \"children\") {\n        children = value;\n      } else {\n        if (key.startsWith(\"attr:\")) {\n          const name = key.slice(5);\n          if (isSubscribable(value)) {\n            push(cleanups, $attr(this, name, value));\n          } else {\n            attr(this, name, value);\n          }\n        } else {\n          // @ts-expect-error unsafe property assign\n          others[key] = value;\n        }\n      }\n    }\n    if (ref) {\n      ref.current = this;\n    }\n    this.props = others;\n    this.#children = children;\n  }\n  /**\n   * The render function, should behave like the functional component.\n   */\n  public abstract render(): Mountable<any>;\n  /**\n   * The mount steps. Manually assign the slots or insert named slots,\n   * and then attach the component instance to the parent view.\n   * @param attach the attach function\n   * @returns rendered result\n   */\n  public mount(attach?: AttachFunc): Rendered<this> {\n    let rendered = this.#rendered;\n    if (rendered) {\n      return rendered;\n    }\n    const newTarget = this.#newTarget;\n    const { tag, shadowRootInit } = newTarget;\n    const slotAssignment = shadowRootInit?.slotAssignment;\n    const shadow = this.attachShadow({\n      ...shadowRootInit,\n      mode: \"open\",\n    });\n    const [cleanup] = mount(this.render(), shadow);\n    addCleanUp(this.cleanups, cleanup);\n    const children = this.#children;\n    if (children) {\n      if (slotAssignment === \"manual\") {\n        assignSlotMap(mount, this, children, this.cleanups);\n      } else {\n        insertSlotMap(mount, this, children, newTarget.slotTag ?? slotName(tag), this.cleanups);\n      }\n      // Free the slot map object since it will never be used again.\n      this.#children = void 0;\n    }\n    rendered = this.#rendered = [() => this.unmount(), this, () => [this, this]];\n    attach?.(this);\n    return rendered;\n  }\n  /**\n   * The unmount steps.\n   */\n  public unmount(): void {\n    if (this.#rendered) {\n      applyAll(this.cleanups);\n      this.shadowRoot.innerHTML = \"\";\n      this.#rendered = void 0;\n    }\n  }\n}\n","import type { HyplateElement } from \"./types.js\";\n\nconst ce = customElements;\n\nexport const anonymousElement = () =>\n  class HyplateAnonymousElement<T> extends HTMLElement implements HyplateElement<T> {\n    declare exposed: T;\n  };\n\nexport const define = /* #__PURE__ */ ce.define.bind(ce);\n","import { appendChild, attr, element } from \"./core.js\";\nimport { addCleanUp, isFragment, isNode, isValidSlotContent } from \"./internal.js\";\nimport type { AttachFunc, CleanUpFunc, NativeSlotContent, Renderer, SlotContent, SlotMap } from \"./types.js\";\nimport { fori, push } from \"./util.js\";\n\nexport const slotName = (name: string) => `${name}-slot`;\n\nexport const insertSlot = (host: Element, slotName: string, element: Element) => {\n  attr(element, \"slot\", slotName);\n  appendChild(host)(element);\n};\n\nexport const assignSlot = (host: Element, slot: HTMLSlotElement, contents: NativeSlotContent[]) => {\n  host.append(...contents);\n  slot.assign(...contents);\n};\n\nconst validateSlotContent = (node: Node, contents: NativeSlotContent[]) => {\n  if (isValidSlotContent(node)) {\n    push(contents, node);\n  } else if (isFragment(node)) {\n    for (let child = node.firstChild; child; child = child.nextSibling) {\n      validateSlotContent(child, contents);\n    }\n  }\n};\n\nconst renderSlotContent = (mount: Renderer, content: SlotContent, cleanups: CleanUpFunc[]): NativeSlotContent[] => {\n  const contents: NativeSlotContent[] = [];\n  if (isNode(content)) {\n    validateSlotContent(content, contents);\n  } else {\n    const attach: AttachFunc = (node) => {\n      validateSlotContent(node, contents);\n    };\n    const [cleanup] = mount(content, attach);\n    addCleanUp(cleanups, cleanup);\n  }\n  return contents;\n};\n\nexport const assignSlotMap = (mount: Renderer, host: Element, slotMap: SlotMap, cleanups: CleanUpFunc[]): void => {\n  fori(host.shadowRoot!.querySelectorAll(\"slot\"), (slot) => {\n    const { name } = slot;\n    if (!(name in slotMap)) {\n      return;\n    }\n    const content = slotMap[name];\n    if (!content) {\n      return;\n    }\n    const contents = renderSlotContent(mount, content, cleanups);\n    if (contents.length) {\n      assignSlot(host, slot, contents);\n    }\n  });\n};\n\nexport const insertSlotMap = (\n  mount: Renderer,\n  host: Element,\n  slotMap: SlotMap,\n  slotTag: string,\n  cleanups: CleanUpFunc[]\n): void => {\n  for (const name in slotMap) {\n    const content = slotMap[name];\n    if (!content) {\n      continue;\n    }\n    const contents = renderSlotContent(mount, content, cleanups);\n    const slotContainer = element(slotTag);\n    slotContainer.append(...contents);\n    insertSlot(host, name, slotContainer);\n  }\n};\n","/**\n * @license MIT\n * Copyright (C) 2022  DarrenDanielDay <Darren_Daniel_Day@hotmail.com>\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { arrayFrom, compare, err, isFunction, noop, warned, __DEV__ } from \"./util.js\";\nimport type {\n  AttachFunc,\n  CleanUpFunc,\n  ConditionalMountable,\n  ExposeBase,\n  ForProps,\n  Mountable,\n  Props,\n  Rendered,\n  Subscribable,\n} from \"./types.js\";\nimport { withCommentRange } from \"./internal.js\";\nimport { before, moveRange } from \"./core.js\";\nimport { subscribe } from \"./binding.js\";\nimport { unmount } from \"./jsx-runtime.js\";\n\nconst createIfDirective = <Test, T extends ExposeBase, F extends ExposeBase = void>(\n  condition: Subscribable<Test>,\n  trueResult: ConditionalMountable<Test, T>,\n  falseResult?: Mountable<F>\n): Mountable<void> => {\n  return (attach) => {\n    const [begin, end, clearRange] = withCommentRange(\"if/show directive\");\n    attach(begin);\n    attach(end);\n    const attachContent: AttachFunc = before(end);\n    let lastAttached: CleanUpFunc | null = null;\n    const unsubscribe = subscribe(condition, (newValue) => {\n      const shouldReRender = !!newValue;\n      lastAttached?.();\n      clearRange();\n      if (shouldReRender) {\n        // @ts-expect-error truty check\n        [lastAttached] = trueResult(attachContent, newValue);\n      } else {\n        [lastAttached] = falseResult?.(attachContent) ?? [null, void 0];\n      }\n    });\n    return [\n      () => {\n        unsubscribe();\n        lastAttached?.();\n      },\n      void 0,\n      () => [begin, end],\n    ];\n  };\n};\nconst nilRendered: Rendered<void> = [noop, void 0, noop];\n/**\n * Use `nil` for render nothing.\n */\nexport const nil: Mountable<void> = () => nilRendered;\n\n/**\n * The `If` directive for conditional rendering.\n */\nexport const If = <Test, T extends ExposeBase, F extends ExposeBase = void>({\n  condition,\n  children,\n}: Props<{ condition: Subscribable<Test> }, { then: ConditionalMountable<Test, T>; else?: Mountable<F> }, void>) => {\n  if (!children) {\n    return warned(\"Invalid usage of 'If'. Must provide children.\", nil);\n  }\n  return createIfDirective(condition, children.then, children.else);\n};\n\n/**\n * The `Show` directive for conditional rendering.\n *\n * Same underlying logic with the {@link If} directive but with different styles of API.\n */\nexport const Show = <Test, T extends ExposeBase, F extends ExposeBase = void>({\n  when,\n  children,\n  fallback,\n}: Props<{ when: Subscribable<Test>; fallback?: Mountable<F> }, ConditionalMountable<Test, T>, void>) => {\n  if (!children) {\n    return warned(\"Invalid usage of 'Show'. Must provide children.\", nil);\n  }\n  return createIfDirective(when, children, fallback);\n};\n/**\n * @internal\n */\ntype HNode<T> = [item: T, rendered: Rendered<any> | undefined];\nconst unmountHNode = (node: HNode<any>) => {\n  const rendered = node[1]!;\n  unmount(rendered);\n};\nconst initAsZero = () => 0;\n/**\n * The `for` directive for list rendering.\n *\n * The `children` must be a render function.\n *\n * `Vue.JS` reference: {@link https://github.com/vuejs/core/blob/main/packages/runtime-core/src/renderer.ts#L1747}\n */\nexport const For = <T extends unknown>({\n  of,\n  children,\n}: Props<ForProps<T>, (item: T) => Mountable<any>>): Mountable<void> => {\n  if (__DEV__) {\n    if (!isFunction(children)) {\n      err(\"Invalid `children` of `For` directive. Expected to be a function.\");\n    }\n  }\n  return (attach): Rendered<void> => {\n    let nodes: HNode<T>[] = [];\n    const [begin, end, removeRange] = withCommentRange(\"for directive\");\n    attach(begin);\n    attach(end);\n    const cleanup = subscribe(of, (newOf) => {\n      const newNodes: HNode<T>[] = [];\n      for (let i = 0, l = newOf.length; i < l; i++) {\n        newNodes.push([newOf[i], void 0]);\n      }\n      let i = 0;\n      const l2 = newNodes.length;\n      let e1 = nodes.length - 1;\n      let e2 = l2 - 1;\n      for (i = 0; i <= e1 && i <= e2; i++) {\n        const n1 = nodes[i];\n        const n2 = newNodes[i];\n        if (compare(n1[0], n2[0])) {\n          n2[1] = n1[1];\n        } else {\n          break;\n        }\n      }\n      for (; i <= e1 && i <= e2; e1--, e2--) {\n        const n1 = nodes[e1];\n        const n2 = newNodes[e2];\n        if (compare(n1[0], n2[0])) {\n          n2[1] = n1[1];\n        } else {\n          break;\n        }\n      }\n      if (i > e1) {\n        if (i <= e2) {\n          const nextPos = e2 + 1;\n          const anchor = newNodes[nextPos]?.[1]![2]()?.[0] ?? end;\n          const attach = before(anchor);\n          for (; i <= e2; i++) {\n            const node = newNodes[i]!;\n            node[1] = children(node[0])(attach);\n          }\n        }\n      } else if (i > e2) {\n        for (; i <= e1; i++) {\n          unmountHNode(nodes[i]);\n        }\n      } else {\n        const s1 = i;\n        const s2 = i;\n        const mapItemToNewIndex = new Map<T, number>();\n        for (i = s1; i <= e2; i++) {\n          const node = newNodes[i]!;\n          const key = node[0];\n          mapItemToNewIndex.set(\n            __DEV__ && mapItemToNewIndex.has(key)\n              ? warned(\n                  `Duplicated item found: ${key}. It's always an error in hyplate,\\\n since hyplate use the item itself as list key.`,\n                  key\n                )\n              : key,\n            i\n          );\n        }\n        let j: number;\n        let patched = 0;\n        const toBePatched = e2 - s2 + 1;\n        let moved = false;\n        let maxNewIndexSoFar = 0;\n        const newIndexToOldIndexMap = arrayFrom({ length: toBePatched }, initAsZero);\n        for (i = s1; i <= e1; i++) {\n          const prevChild = nodes[i]!;\n          if (patched >= toBePatched) {\n            unmountHNode(prevChild);\n            continue;\n          }\n          const newIndex = mapItemToNewIndex.get(prevChild[0]);\n          if (newIndex == null) {\n            unmountHNode(prevChild);\n          } else {\n            newIndexToOldIndexMap[newIndex - s2] = i + 1;\n            if (newIndex >= maxNewIndexSoFar) {\n              maxNewIndexSoFar = newIndex;\n            } else {\n              moved = true;\n            }\n            newNodes[newIndex][1] = prevChild[1];\n            patched++;\n          }\n        }\n        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : [];\n        j = increasingNewIndexSequence.length - 1;\n        for (i = toBePatched - 1; i >= 0; i--) {\n          const nextIndex = s2 + i;\n          const nextChild = newNodes[nextIndex]!;\n          const anchor = newNodes[nextIndex + 1]?.[1]![2]()?.[0] ?? end;\n          const attach = before(anchor);\n          if (newIndexToOldIndexMap[i] === 0) {\n            nextChild[1] = children(nextChild[0])(attach);\n          } else if (moved) {\n            if (j < 0 || i !== increasingNewIndexSequence[j]!) {\n              const range = nextChild[1]![2]();\n              if (range) {\n                moveRange(range[0], range[1], attach);\n              }\n            } else {\n              j--;\n            }\n          }\n        }\n      }\n      nodes = newNodes;\n    });\n    return [\n      () => {\n        // Apply all the cleanup functions in the reversed order.\n        for (let i = nodes.length - 1; i >= 0; i--) {\n          nodes[i][1]![0]();\n        }\n        // Unsubscribe `of`.\n        cleanup();\n        // Remove all DOM nodes in the comment range.\n        removeRange();\n      },\n      void 0,\n      () => [begin, end],\n    ];\n  };\n};\n\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\nconst getSequence = (arr: number[]): number[] => {\n  const p = [...arr];\n  const result = [0];\n  let i: number, j: number, u: number, v: number, c: number;\n  const len = arr.length;\n  for (i = 0; i < len; i++) {\n    const arrI = arr[i];\n    if (arrI !== 0) {\n      j = result[result.length - 1];\n      if (arr[j] < arrI) {\n        p[i] = j;\n        result.push(i);\n        continue;\n      }\n      u = 0;\n      v = result.length - 1;\n      while (u < v) {\n        c = (u + v) >> 1;\n        if (arr[result[c]] < arrI) {\n          u = c + 1;\n        } else {\n          v = c;\n        }\n      }\n      if (arrI < arr[result[u]]) {\n        if (u > 0) {\n          p[i] = result[u - 1];\n        }\n        result[u] = i;\n      }\n    }\n  }\n  u = result.length;\n  v = result[u - 1];\n  while (u-- > 0) {\n    result[u] = v;\n    v = p[v];\n  }\n  return result;\n};\n","/**\n * @license MIT\n * Copyright (C) 2022  DarrenDanielDay <Darren_Daniel_Day@hotmail.com>\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { applyAll, compare, err, __DEV__ } from \"./util.js\";\nimport type { CleanUpFunc, Differ, Query, Source, Subscriber } from \"./types.js\";\nimport { scopes } from \"./util.js\";\nimport { configureBinding } from \"./binding.js\";\nimport { $$HyplateSubscribers } from \"./internal.js\";\n\nlet defaultDiffer: Differ = compare;\nexport const setDiffer = (differ: Differ | undefined | null) => {\n  defaultDiffer = differ ?? compare;\n};\n\nexport const enableBuiltinStore = () => {\n  // @ts-expect-error type should be configured\n  configureBinding(watch, isQuery);\n};\n\nconst [enterScope, quitScope, currentScope] = /* #__PURE__ */ scopes<Set<Query<any>>>();\n\nconst useDepScope = (): [Set<Query<unknown>>, CleanUpFunc] => {\n  const deps = new Set<Query<unknown>>();\n  enterScope(deps);\n  return [deps, quitScope];\n};\n\nclass SourceImpl<T extends unknown> implements Source<T> {\n  [$$HyplateSubscribers] = new Set<Subscriber<T>>();\n  constructor(private _val: T, private _differ: Differ) {}\n  get val() {\n    currentScope()?.add(this);\n    return this._val;\n  }\n  sub(subscriber: Subscriber<T>): CleanUpFunc {\n    this[$$HyplateSubscribers].add(subscriber);\n    return () => {\n      this[$$HyplateSubscribers].delete(subscriber);\n    };\n  }\n  set(newVal: T): void {\n    if (this._differ(this._val, newVal)) {\n      return;\n    }\n    this._val = newVal;\n    dispatch(this[$$HyplateSubscribers], newVal);\n  }\n}\n\nexport const source = <T extends unknown>(val: T, differ: Differ = defaultDiffer): Source<T> => {\n  return new SourceImpl(val, differ);\n};\n\nexport const isQuery = (obj: unknown): obj is Query<unknown> =>\n  // @ts-expect-error unknown key access\n  obj && !!obj[$$HyplateSubscribers];\n\nexport const watch = <T extends unknown>(query: Query<T>, subscriber: Subscriber<T>): CleanUpFunc => {\n  const unsubscribe = query.sub(subscriber);\n  subscriber(query.val);\n  return unsubscribe;\n};\n\nconst dispatch = <T extends unknown>(subscribers: Set<Subscriber<T>>, newVal: T) => {\n  [...subscribers].forEach((sub) => {\n    try {\n      sub(newVal);\n    } catch (error) {\n      err(error);\n    }\n  });\n};\n\nclass QueryImpl<T extends unknown> implements Query<T> {\n  #dirty = true;\n  #current: T | null = null;\n  #teardowns: CleanUpFunc[] = [];\n  [$$HyplateSubscribers] = new Set<Subscriber<T>>();\n  constructor(private readonly _selector: () => T, private _differ: Differ) {}\n  get val() {\n    this.#lazyEvaluate();\n    return this.#current!;\n  }\n  sub(subscriber: Subscriber<T>): CleanUpFunc {\n    const subscribers = this[$$HyplateSubscribers];\n    subscribers.add(subscriber);\n    return () => {\n      subscribers.delete(subscriber);\n      if (!subscribers.size) {\n        applyAll(this.#teardowns);\n      }\n    };\n  }\n  #lazyEvaluate() {\n    currentScope()?.add(this);\n    if (!this.#dirty) {\n      return;\n    }\n    this.#dirty = false;\n    const [newDeps, cleanupDepScope] = useDepScope();\n    this.#current = this._selector();\n    cleanupDepScope();\n    applyAll(this.#teardowns);\n    this.#teardowns = [...newDeps].map((dep) => dep.sub(this.#dispatch));\n  }\n  #dispatch = () => {\n    this.#dirty = true;\n    const last = this.#current;\n    this.#lazyEvaluate();\n    if (this._differ(last, this.#current)) {\n      return;\n    }\n    dispatch(this[$$HyplateSubscribers], this.#current!);\n  };\n}\n\nexport const query = <T extends unknown>(selector: () => T, differ: Differ = defaultDiffer): Query<T> => {\n  return new QueryImpl(selector, differ);\n};\n","export type Numeric = Fraction | Atom;\nexport interface Comparable {\n  equals(n: Numeric): boolean;\n}\nexport interface Operators {\n  add(n: Numeric): Numeric;\n  sub(n: Numeric): Numeric;\n  lsub(n: Numeric): Numeric;\n  mult(n: Numeric): Numeric;\n  div(n: Numeric): Numeric;\n  ldiv(n: Numeric): Numeric;\n}\nexport type Operator = keyof Operators;\nexport interface Expression {\n  a: Expression | number;\n  operator: Operator;\n  b: Expression | number;\n}\nconst gcd = (a: number, b: number) => {\n  let r: number;\n  while ((r = a % b)) {\n    a = b;\n    b = r;\n  }\n  return b;\n};\nconst isAtom = (n: unknown): n is Atom => n instanceof Atom;\nconst isFraction = (n: unknown): n is Fraction => n instanceof Fraction;\nconst die = (msg: string) => {\n  throw new Error(msg);\n};\nclass Atom implements Operators, Comparable {\n  constructor(public readonly value: number) {}\n  equals(n: Numeric): boolean {\n    if (isAtom(n)) {\n      return n.value === this.value;\n    }\n    return n.equals(this);\n  }\n  add(n: Numeric): Numeric {\n    if (isAtom(n)) {\n      return new Atom(this.value + n.value);\n    }\n    return n.add(this);\n  }\n  sub(n: Numeric): Numeric {\n    if (isAtom(n)) {\n      return new Atom(this.value - n.value);\n    }\n    return n.lsub(this);\n  }\n  lsub(n: Numeric): Numeric {\n    if (isAtom(n)) {\n      return new Atom(n.value - this.value);\n    }\n    return n.sub(this);\n  }\n  mult(n: Numeric): Numeric {\n    if (isAtom(n)) {\n      return new Atom(this.value * n.value);\n    }\n    return n.mult(this);\n  }\n  div(n: Numeric): Numeric {\n    if (isAtom(n)) {\n      return Fraction.create(this.value, n.value);\n    }\n    return n.ldiv(this);\n  }\n  ldiv(n: Numeric): Numeric {\n    if (isAtom(n)) {\n      return Fraction.create(n.value, this.value);\n    }\n    return n.div(this);\n  }\n}\nclass Fraction implements Operators, Comparable {\n  static create(dividend: number, divisor: number) {\n    const m = gcd(dividend, divisor);\n    dividend /= m;\n    divisor /= m;\n    if (divisor !== 1) {\n      return new Fraction(dividend, divisor);\n    }\n    return new Atom(dividend);\n  }\n  private constructor(\n    public readonly dividend: number,\n    public readonly divisor: number\n  ) {}\n\n  equals(n: Numeric): boolean {\n    const { dividend, divisor } = this;\n    if (isAtom(n)) {\n      return dividend / divisor === n.value;\n    }\n    if (isFraction(n)) {\n      const { dividend: a, divisor: b } = n;\n      return a * divisor === b * dividend;\n    }\n    return die(`Unsupported \"Numeric\" type.`);\n  }\n\n  add(n: Numeric): Numeric {\n    let { dividend, divisor } = this;\n    if (isAtom(n)) {\n      dividend += n.value * this.divisor;\n    } else if (isFraction(n)) {\n      const { dividend: a, divisor: b } = this;\n      const { divisor: c, dividend: d } = n;\n      divisor = b * d;\n      dividend = a * d + b * c;\n    } else {\n      return die(`Unsupported \"Numeric\" type.`);\n    }\n    return Fraction.create(dividend, divisor);\n  }\n  sub(n: Numeric): Numeric {\n    let { dividend, divisor } = this;\n    if (isAtom(n)) {\n      dividend -= n.value * divisor;\n    } else if (isFraction(n)) {\n      const { dividend: a, divisor: b } = this;\n      const { divisor: c, dividend: d } = n;\n      divisor = b * d;\n      dividend = a * d - b * c;\n    } else {\n      return die(`Unsupported \"Numeric\" type.`);\n    }\n    return Fraction.create(dividend, divisor);\n  }\n  lsub(n: Numeric): Numeric {\n    let { dividend, divisor } = this;\n    if (isAtom(n)) {\n      dividend = n.value * divisor - dividend;\n    } else if (isFraction(n)) {\n      const { dividend: a, divisor: b } = this;\n      const { divisor: c, dividend: d } = n;\n      divisor = b * d;\n      dividend = b * c - a * d;\n    } else {\n      return die(`Unsupported \"Numeric\" type.`);\n    }\n    return Fraction.create(dividend, divisor);\n  }\n  mult(n: Numeric): Numeric {\n    let { dividend, divisor } = this;\n    if (isAtom(n)) {\n      dividend *= n.value;\n    } else if (isFraction(n)) {\n      divisor *= n.divisor;\n      dividend *= n.dividend;\n    } else {\n      return die(`Unsupported \"Numeric\" type.`);\n    }\n    return Fraction.create(dividend, divisor);\n  }\n  div(n: Numeric): Numeric {\n    let { dividend, divisor } = this;\n    if (isAtom(n)) {\n      divisor *= n.value;\n    } else if (isFraction(n)) {\n      divisor *= n.dividend;\n      dividend *= n.divisor;\n    } else {\n      return die(`Unsupported \"Numeric\" type.`);\n    }\n    return Fraction.create(dividend, divisor);\n  }\n  ldiv(n: Numeric): Numeric {\n    let { dividend, divisor } = this;\n    if (isAtom(n)) {\n      [divisor, dividend] = [dividend, n.value * divisor];\n    } else if (isFraction(n)) {\n      [divisor, dividend] = [n.divisor * dividend, n.dividend * divisor];\n    } else {\n      return die(`Unsupported \"Numeric\" type.`);\n    }\n    return Fraction.create(dividend, divisor);\n  }\n}\n\ninterface ListNode<T> {\n  value: T;\n  next: ListNode<T> | undefined;\n  prev: ListNode<T> | undefined;\n}\n\nconst insert = <T extends unknown>(\n  instance: DoubleLinkedList<T>,\n  prop: \"front\" | \"back\",\n  value: T\n) => {\n  const link = prop === \"back\" ? \"next\" : \"prev\";\n  const { [prop]: node } = instance;\n  const newNode: ListNode<T> = { value, prev: undefined, next: undefined };\n  if (!node) {\n    instance.front = instance.back = newNode;\n  } else {\n    instance[prop] = node[link] = newNode;\n  }\n};\n\nconst remove = <T extends unknown>(\n  instance: DoubleLinkedList<T>,\n  prop: \"front\" | \"back\"\n) => {\n  const link = prop === \"back\" ? \"prev\" : \"next\";\n  const unlink = prop === \"back\" ? \"next\" : \"prev\";\n  const { [prop]: node } = instance;\n  if (node) {\n    const connection = node[link];\n    if (connection) {\n      connection[unlink] = undefined;\n      instance[prop] = connection;\n    } else {\n      instance.front = instance.back = undefined;\n    }\n  }\n};\n\nclass DoubleLinkedList<T> {\n  front: ListNode<T> | undefined;\n  back: ListNode<T> | undefined;\n  push(value: T) {\n    insert(this, \"back\", value);\n  }\n  pop() {\n    remove(this, \"back\");\n  }\n  enqueue(value: T) {\n    insert(this, \"front\", value);\n  }\n  dequeue() {\n    remove(this, \"front\");\n  }\n}\n\nexport const solve = (\n  atoms: number[],\n  operators: Operator[],\n  target: number\n) => {\n  const compare = new Atom(target);\n  const opLength = operators.length;\n  const atomLength = atoms.length;\n  const find = (start: number) => {\n    const usedIndex = new Set<number>();\n    usedIndex.add(start);\n    const atom = atoms[start];\n    let numeric: Numeric = new Atom(atom);\n    let expr: Expression | number = atom;\n    const invoke = () => {\n      if (usedIndex.size === atomLength) {\n        if (numeric.equals(compare)) {\n          throw expr;\n        }\n      }\n      for (let i = 0; i < atomLength; i++) {\n        if (usedIndex.has(i)) {\n          continue;\n        }\n        usedIndex.add(i);\n        const atom = atoms[i]!;\n        const operand = new Atom(atom);\n        for (let j = 0; j < opLength; j++) {\n          const op = operators[j]!;\n          const lastNumeric = numeric;\n          const lastExpr = expr;\n          numeric = numeric[op](operand);\n          expr = {\n            a: expr,\n            operator: op,\n            b: atom,\n          };\n          invoke();\n          expr = lastExpr;\n          numeric = lastNumeric;\n        }\n        usedIndex.delete(i);\n      }\n    };\n    invoke();\n  };\n  try {\n    for (let i = 0; i < atomLength; i++) {\n      find(i);\n    }\n  } catch (error) {\n    return error as Expression;\n  }\n  throw new Error(\"No solution.\");\n};\n","import { appendChild } from \"hyplate/core\";\nimport { For, Show } from \"hyplate/directive\";\nimport { jsxRef, mount } from \"hyplate/jsx-runtime\";\nimport { source, enableBuiltinStore, query } from \"hyplate/store\";\nimport type { FC, Later, Query } from \"hyplate/types\";\nimport { type Expression, type Operator, solve } from \"./calculate\";\n\nenableBuiltinStore();\ndeclare module \"hyplate/types\" {\n  export interface Subscribable<T> extends Query<T> {}\n}\nconst render = (e: Expression | number): JSX.Element => {\n  if (typeof e === \"number\") {\n    return renderNumber(e);\n  }\n  return (\n    <mrow>\n      {e.operator.startsWith(\"l\")\n        ? renderAB(e.b, e.a, e.operator)\n        : renderAB(e.a, e.b, e.operator)}\n    </mrow>\n  );\n};\n\nconst renderNumber = (n: number): JSX.Element => {\n  if (n < 0) {\n    return (\n      <>\n        <mo fence>(</mo>\n        <mn>{n}</mn>\n        <mo fence>)</mo>\n      </>\n    );\n  }\n  return <mn>{n}</mn>;\n};\n\nconst wrappedRender = (\n  e: Expression | number,\n  parentOp: Operator,\n  isRightExpr?: boolean\n): JSX.Element => {\n  if (typeof e === \"number\") {\n    return renderNumber(e);\n  }\n  const op = e.operator;\n  if (\n    ((op === \"add\" || op === \"sub\" || op === \"lsub\") && parentOp === \"mult\") ||\n    (isRightExpr && (parentOp === \"sub\" || parentOp === \"lsub\"))\n  ) {\n    return (\n      <>\n        <mo fence>(</mo>\n        {render(e)}\n        <mo fence>)</mo>\n      </>\n    );\n  }\n  return render(e);\n};\nconst renderAB = (\n  a: Expression | number,\n  b: Expression | number,\n  op: Operator\n) => {\n  if (op === \"div\" || op === \"ldiv\") {\n    return (\n      <mfrac>\n        {wrappedRender(a, op)}\n        {wrappedRender(b, op, true)}\n      </mfrac>\n    );\n  }\n  return (\n    <>\n      {wrappedRender(a, op)}\n      <mo>{OperatorNames[op]}</mo>\n      {wrappedRender(b, op, true)}\n    </>\n  );\n};\nconst OperatorNames: Record<Operator, string> = {\n  add: \"+\",\n  div: \"/\",\n  ldiv: \"/\",\n  lsub: \"-\",\n  mult: \"×\",\n  sub: \"-\",\n};\nconst App: FC = () => {\n  const list = source<{ ref: Later<HTMLInputElement> }[]>(\n    Array.from({ length: 4 }, () => ({ ref: jsxRef() }))\n  );\n  const expected = source(24);\n  const pointsText = query(() => {\n    const count = expected.val;\n    return `${count} ${count > 1 ? \"points\" : \"point\"}`;\n  });\n  const res = source<JSX.Element | null>(null);\n  const calculate = () => {\n    const atoms = list.val.map((p) => +p.ref.current!.value);\n    try {\n      const expr = solve(\n        atoms,\n        [\"add\", \"sub\", \"lsub\", \"mult\", \"div\", \"ldiv\"],\n        +expected.val\n      );\n      res.set(\n        <math display=\"block\">\n          {render(expr)}\n          <mo>=</mo>\n          <mn>{expected.val}</mn>\n        </math>\n      );\n    } catch (error) {\n      res.set(\n        <math display=\"block\">\n          <ms>No solution.</ms>\n        </math>\n      );\n    }\n  };\n  return (\n    <div class=\"app mx-3 my-3\">\n      <form\n        onSubmit={(e) => {\n          e.preventDefault();\n          calculate();\n        }}\n      >\n        <div class=\"mb-3\">\n          <label for=\"count\" class=\"form-label\">\n            number count:\n          </label>\n          <input\n            id=\"count\"\n            class=\"form-control\"\n            name=\"count\"\n            type=\"number\"\n            required\n            min=\"1\"\n            max=\"10\"\n            value={list.val.length}\n            onChange={function () {\n              const count = +this.value;\n              const oldList = list.val;\n              if (count !== oldList.length) {\n                const newList =\n                  oldList.length > count\n                    ? oldList.slice(0, count)\n                    : oldList.concat(\n                        Array.from({ length: count - oldList.length }, () => ({\n                          ref: jsxRef<HTMLInputElement>(),\n                        }))\n                      );\n                list.set(newList);\n              }\n            }}\n          ></input>\n        </div>\n        <div class=\"mb-3\">\n          <label for=\"sum\" class=\"form-label\">\n            expected result:\n          </label>\n          <input\n            onChange={function () {\n              const val = +this.value;\n              if (!isNaN(val)) {\n                expected.set(val);\n              }\n            }}\n            class=\"form-control\"\n            id=\"sum\"\n            name=\"sum\"\n            value=\"24\"\n            required\n            type=\"number\"\n          ></input>\n        </div>\n        <div class=\"mb-3 row g-3\">\n          <For of={list}>\n            {(p) => {\n              return (\n                <div class=\"col\">\n                  <label class=\"form-label\">\n                    input #{1 + list.val.indexOf(p)}\n                    <input class=\"form-control\" required ref={p.ref}></input>\n                  </label>\n                </div>\n              );\n            }}\n          </For>\n        </div>\n        <button class=\"btn btn-primary\" type=\"submit\">\n          solve {pointsText}\n        </button>\n        <div>\n          <Show when={res}>{(attach, expr) => mount(expr, attach)}</Show>\n        </div>\n      </form>\n    </div>\n  );\n};\n\nmount(<App></App>, appendChild(document.body));\n"],"names":["$9492a9347601e1c6$export$a866f231438cc228","Object","assign","$9492a9347601e1c6$export$b1a47efd00197c76","Array","from","$9492a9347601e1c6$export$4cbf152802aa238","arr","val","push","$9492a9347601e1c6$export$3e41007ebfff0e64","pop","$9492a9347601e1c6$export$8793edee2d425525","$9492a9347601e1c6$export$c396f8c87255c5a5","cleanups","i","length","$9492a9347601e1c6$export$2b09fb321900f3b3","$9492a9347601e1c6$export$844ec244b1367d54","v","$9492a9347601e1c6$export$f6e2535fb5126e54","$9492a9347601e1c6$export$a6cdc56e425d0d0a","$9492a9347601e1c6$export$43bee75e5e14138e","isArray","$9492a9347601e1c6$export$d9817fe6e73182b","ctor","value","$9492a9347601e1c6$export$398604a469f7de9a","is","defineProperty","$9492a9347601e1c6$export$8048b892d651b310","error","msg","Error","stack","JSON","stringify","console","$9492a9347601e1c6$export$c106dd0671a0fc2d","warn","$9492a9347601e1c6$export$f389a4af03e8aca7","$9492a9347601e1c6$export$d71ad7e5de6da5ad","arrayLike","callback","l","$c2a998ebc17b2063$export$2a111da947c407d2","document","$c2a998ebc17b2063$export$4a34f930e789283c","message","createComment","$c2a998ebc17b2063$export$43c712bf797a0493","begin","end","range","Range","setStart","setEnd","deleteContents","detach","$c2a998ebc17b2063$export$c154795de99395b7","cleanup","$c2a998ebc17b2063$export$36e4a2c48c79ce21","target","name","hander","options","addEventListener","removeEventListener","$c2a998ebc17b2063$export$964008797577f87a","el","event","handler","root","ownerDocument","delegatedEvents","$$delegates","Set","has","add","$c2a998ebc17b2063$var$globalDelegateEventHandler","handlerProperty","e","eventHandlerProperty","type","targets","composedPath","call","$c2a998ebc17b2063$export$8ee0fc9ee280b4ee","Node","$c2a998ebc17b2063$export$9522e17588c12572","DocumentFragment","$c2a998ebc17b2063$export$d2aba6e3949c634a","HTMLTemplateElement","Text","Element","$63cb1693dcc6d111$export$8454457683f90105","createElement","bind","$63cb1693dcc6d111$export$6f093cfa640b7166","createTextNode","$63cb1693dcc6d111$export$7ed1367e7fa1ad68","createElementNS","$63cb1693dcc6d111$export$47d5b44d225be5b4","$63cb1693dcc6d111$export$f00aeb236b6f05af","createDocumentFragment","$63cb1693dcc6d111$export$7aabe8b3a840d2fd","element","removeAttribute","setAttribute","$63cb1693dcc6d111$export$1b8e57c9ea42f1d2","host","node","appendChild","$63cb1693dcc6d111$export$1c4c1e3098bf5ebe","anchorNode","parentNode","insertBefore","$63cb1693dcc6d111$export$cd7f480d6b8286c3","removeChild","$63cb1693dcc6d111$export$71fab7eb76d05d5a","attach","nextSibling","$63cb1693dcc6d111$export$df89bc4a93f2927c","getRange","$0d6013573e0e298a$var$defaultSubscribe","subscribable","subscriber","$0d6013573e0e298a$export$ec068583843480e7","$0d6013573e0e298a$var$defaultIsSubscribable","$0d6013573e0e298a$export$afa9d06a32b253a4","$0d6013573e0e298a$export$68028ad1cb93a754","fragments","bindings","bindingsLength","some","binding","effects","buf","flushBuf","textContent","join","textNode","expression","dynamicText","data","at","$0d6013573e0e298a$export$2020da9baeb580d2","attribute","$02a176ad5b49a0a6$export$186d02efde07ef98","customElements","onto","$02a176ad5b49a0a6$export$121e2d597d222bad","rendered","$02a176ad5b49a0a6$var$addChild","child","$02a176ad5b49a0a6$var$renderChild","children","_attach","isFrag","firstChild","lastChild","$02a176ad5b49a0a6$var$currentElementFactory","$02a176ad5b49a0a6$export$34b9dba7ce09269b","props","lastElementFactory","isSvg","isForeignObject","isMath","changnigFactory","ref","attributes","current","key","startsWith","next","slice","toLowerCase","handleEvent","$02a176ad5b49a0a6$export$45118db60eed6f35","mount","otherProps","mountable","$02a176ad5b49a0a6$export$25062201e9e25d76","$02a176ad5b49a0a6$export$ffb0004e005737fa","f","fn","__hyplate_comp","$02a176ad5b49a0a6$export$16fa2f45be04daa8","HTMLElement","static","tag","$aa9c104c9d2dfa74$export$f36d6a7a5c09a23e","this","shadowRootInit","slotAssignment","slotTag","$4b253a87e73908fc$export$7aeaa1ca2e4d7cb5","observedAttributes","slots","$c2a998ebc17b2063$export$f49cbeca3e22a85e","newTarget","constructor","super","setup","defaultProps","others","shadow","attachShadow","mode","render","slotMap","shadowRoot","querySelectorAll","slot","content","contents","$4b253a87e73908fc$var$renderSlotContent","append","$4b253a87e73908fc$export$bb9e962662828fb1","$4b253a87e73908fc$export$88f5bf723c76b672","unmount","innerHTML","$86024dacded2e245$var$createIfDirective","condition","trueResult","falseResult","clearRange","attachContent","lastAttached","unsubscribe","newValue","shouldReRender","$86024dacded2e245$var$nilRendered","$86024dacded2e245$export$f2c4f74e8fe88e34","$86024dacded2e245$export$f6a3d19be20f5819","when","fallback","$86024dacded2e245$var$unmountHNode","$86024dacded2e245$var$initAsZero","$86024dacded2e245$export$bdf530073099ce9f","of","nodes","removeRange","newOf","newNodes","l2","e1","e2","n1","n2","anchor","s1","s2","mapItemToNewIndex","Map","set","j","patched","toBePatched","moved","maxNewIndexSoFar","newIndexToOldIndexMap","prevChild","newIndex","get","increasingNewIndexSequence","$86024dacded2e245$var$getSequence","nextIndex","nextChild","p","result","u","c","len","arrI","$bb162890262cc693$var$defaultDiffer","$bb162890262cc693$var$enterScope","$bb162890262cc693$var$quitScope","$bb162890262cc693$var$currentScope","$bb162890262cc693$var$SourceImpl","_val","_differ","sub","delete","newVal","$bb162890262cc693$var$dispatch","$bb162890262cc693$export$b4d5da5f34fb77ad","differ","$bb162890262cc693$export$605ec01fbf39a5e1","obj","$bb162890262cc693$export$3db5d71bdb2d5499","query","subscribers","forEach","$bb162890262cc693$var$QueryImpl","_selector","dirty","teardowns","lazyEvaluate","size","newDeps","cleanupDepScope","deps","$bb162890262cc693$var$useDepScope","map","dep","dispatch","last","$bb162890262cc693$export$2fa187e846a241c4","selector","$b4ad3719bd026889$var$isAtom","n","$b4ad3719bd026889$var$Atom","$b4ad3719bd026889$var$isFraction","$b4ad3719bd026889$var$Fraction","$b4ad3719bd026889$var$die","equals","lsub","mult","div","create","ldiv","dividend","divisor","m","a","b","r","$b4ad3719bd026889$var$gcd","d","$b4ad3719bd026889$export$2865df1f26e73f8e","atoms","operators","compare","opLength","atomLength","find","start","usedIndex","atom","numeric","expr","invoke","operand","op","lastNumeric","lastExpr","operator","$a88ea9323d3a23c8$var$render","$a88ea9323d3a23c8$var$renderNumber","$a88ea9323d3a23c8$var$renderAB","fence","$a88ea9323d3a23c8$var$wrappedRender","parentOp","isRightExpr","$a88ea9323d3a23c8$var$OperatorNames","$a88ea9323d3a23c8$var$App","list","expected","pointsText","count","res","calculate","display","class","onSubmit","preventDefault","for","id","required","min","max","onChange","oldList","newList","concat","isNaN","indexOf","body"],"version":3,"file":"index.a418c0f7.js.map"}